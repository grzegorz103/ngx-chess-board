import { Color } from './pieces/color';
import { King } from './pieces/king';
import { Pawn } from './pieces/pawn';
import { Piece } from './pieces/piece';
import { Point } from './pieces/point';
export declare class Board {
    board: number[][];
    pieces: Piece[];
    enPassantPoint: Point;
    enPassantPiece: Piece;
    lastMoveSrc: Point;
    lastMoveDest: Point;
    activePiece: Piece;
    blackKingChecked: boolean;
    possibleCaptures: any[];
    possibleMoves: Point[];
    whiteKingChecked: boolean;
    currentWhitePlayer: boolean;
    reverted: boolean;
    fullMoveCount: number;
    fen: string;
    constructor();
    isXYInPossibleMoves(row: number, col: number): boolean;
    isXYInPossibleCaptures(row: number, col: number): boolean;
    isXYInSourceMove(i: number, j: number): boolean;
    isXYInDestMove(i: number, j: number): boolean;
    isXYInActiveMove(i: number, j: number): boolean;
    isPointInPossibleMoves(point: Point): boolean;
    isPointInPossibleCaptures(point: Point): boolean;
    reset(): void;
    reverse(): void;
    clone(): Board;
    isFieldTakenByEnemy(row: number, col: number, enemyColor: Color): boolean;
    isFieldEmpty(row: number, col: number): boolean;
    isFieldUnderAttack(row: number, col: number, color: Color): boolean;
    getPieceByField(row: number, col: number): Piece;
    isKingInCheck(color: Color, pieces: Piece[]): boolean;
    getKingByColor(color: Color): King;
    getCastleFENString(color: Color): string;
    getEnPassantFENString(): string;
    calculateFEN(): void;
    isXYInPointSelection(i: number, j: number): boolean;
    private reversePoint;
    getPieceByPoint(row: number, col: number): Piece;
    checkIfPawnTakesEnPassant(newPoint: Point): void;
    checkIfPawnEnpassanted(piece: Pawn, newPoint: Point): void;
    isKingChecked(piece: Piece): boolean;
}
